# KD Tree: 効率的なアルゴリズムとデータ構造

---

## 問題提起: 一番近い点はどれ？

- 平面上に4つの点があります (A, B, C, D)
- **点Aに一番近いのはどの点でしょう？**
- 距離を計算して最短のものを選びます
  - AB, AC, ADの長さを測る
- めでたしめでたし…ではない！

---

## 計算量の爆発

- 点が10万個だったら？
  - Aに一番近い点を探す: 99,999回の計算
  - Bに一番近い点を探す: 99,998回
- **総計で約5兆回の計算！**
- このままではリアルタイム処理は不可能

## ワインの毒味係クイズ

- **問題:**  
  - ワインが4本あります。そのうち1本だけ毒が入っています
  - 飲んでから1日後に毒の効果が現れます
- **質問:**  
  - 毒味係は何人いれば毒入りワインを特定できるでしょう？
  - **4人以下で可能な方法があります！**

---

## 毒味係の効率的な使い方

- **毒味係が少なくて済む理由:**
  - 毒味係1号と2号を使い、飲む組み合わせを工夫する
  - ワインの番号をビットに割り当てる
    - ワイン1: 00（どちらも飲まない）
    - ワイン2: 01（1号だけ飲む）
    - ワイン3: 10（2号だけ飲む）
    - ワイン4: 11（両方飲む）
- **結果:**
  - 毒味係が死んだ組み合わせで毒入りワインを特定可能！

---

## ワインが1000本あったら？

- **拡張:**  
  - ワインが8本なら毒味係は3人  
  - ワインが1000本でも毒味係は10人でOK！
- **ポイント:**  
  - 試行の効率化により、探索コストが指数的ではなく対数的に抑えられる
  - **情報を効率的に分配・収集するアルゴリズムの力！**

---

## 効率化の鍵: KD Tree

- KD Treeは空間を分割して、探索を効率化する仕組みです
- **操作の概要:**
  1. 平面上に線を引いて領域を2分割
  2. 対象点がどの領域に属するかを判断
  3. 同じ領域内の点だけを候補に絞り込み

---

## 候補の減り方を比較

- 引き算: 1回の操作で候補が1つ減る
- KD Tree: 1回の操作で候補が**半分**に減る
- **引き算 vs 割り算…どっちが速い？**
  - 答えは明らか！

---

## 次元の拡張: R^2からR^dへ

- KD Treeの仕組みはどの次元でも同じ
  - 3次元空間 (R^3) でも、一般の d次元空間 (R^d) でも適用可能
- 計算量:
  - **KD Tree**: O(d log n)
  - **全探索**: O(n^2)
- **次元が増えても効率的！**

---

## 実際の応用例

1. **点群データ解析**
   - 3DスキャンやLiDARデータの効率的な解析
2. **特徴量ベクトルの類似度**
   - 趣味や好みの近いユーザーの探索
3. **Hausdorff距離の計算**
   - 形状比較や最大誤差評価

---

## アルゴリズムの現実的な使い方

- **新しいアルゴリズムを作るのは難しい**
- しかし…
  - 自分の課題に適したアルゴリズムが既にあるかもしれない
  - 他分野のメジャーなアルゴリズムを応用できるかも
- SciPyなどのライブラリを活用しよう
  - **インポートするだけで便利な関数が使える！**

---

## 結論: 振り返ることの重要性

- 自分の問題を効率化できるアルゴリズムがないか、ぜひ振り返ってみよう！
- **「無駄を省いて本質に迫る」**
  - それが効率的なアルゴリズムの力です

---

## ありがとうございました！

- 質問があればぜひどうぞ！
